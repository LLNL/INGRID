from __future__ import print_function
import numpy as np
import re
import copy
from scipy.interpolate import RectBivariateSpline as RectBivariateSplineNaN # replace the function from OMFIT
import warnings


printi = print
basestring = str


############################
# G-FILE CLASS OMFITgeqdsk #
############################
class OMFITgeqdsk(dict):#(SortedDict, OMFITascii):
    """
    class used to interface G files generated by EFIT
    :param filename: filename passed to OMFITascii class
    :param \**kw: keyword dictionary passed to OMFITascii class
    """
    def __init__(self, filename, **kw):
        """
        Method used to read g-files
        :param raw: load gEQDSK exactly as it's on file, regardless of COCOS
        """
#        OMFITascii.__init__(self, filename, **kw)
#        SortedDict.__init__(self, caseInsensitive=True)
#        self._cocos = 1
#        self._AuxNamelistString = None
#        self.dynaLoad = True
        def splitter(inv, step=16):
            value = []
            for k in range(int(len(inv) / step)):
                value.append(inv[step * k:step * (k + 1)])
            return value

        def merge(inv):
            return ''.join(inv)
        
        self.clear()

        # clean lines from the carriage returns
        with open(filename, 'r') as f:
            EQDSK = f.read().splitlines()

        # first line is description and sizes
        self['CASE'] = np.array(splitter(EQDSK[0][0:48], 8))
        try:
            tmp = list([_f for _f in EQDSK[0][48:].split(' ') if _f])
            [IDUM, self['NW'], self['NH']] = list(map(int, tmp[:3]))
        except ValueError: # Can happen if no space between numbers, such as 10231023
            IDUM = int(EQDSK[0][48:52])
            self['NW'] = int(EQDSK[0][52:56])
            self['NH'] = int(EQDSK[0][56:60])
            tmp = []
#            printd('IDUM, NW, NH',IDUM,self['NW'],self['NH'],topic='OMFITgeqdsk.load')
        if len(tmp) > 3:
            self['EXTRA_HEADER'] = EQDSK[0][49 + len(re.findall('%d +%d +%d ' % (IDUM, self['NW'], self['NH']), EQDSK[0][49:])[0]) + 2:]
        offset = 1

        # now, the next 20 numbers (5 per row)
        [self['RDIM'], self['ZDIM'], self['RCENTR'], self['RLEFT'], self['ZMID'], \
         self['RMAXIS'], self['ZMAXIS'], self['SIMAG'], self['SIBRY'], self['BCENTR'], \
         self['CURRENT'], self['SIMAG'], XDUM, self['RMAXIS'], XDUM, \
         self['ZMAXIS'], XDUM, self['SIBRY'], XDUM, XDUM] = list(map(eval, splitter(merge(EQDSK[offset:offset + 4]))))
        offset = offset + 4

        # now I have to read NW elements
        nlNW = int(np.ceil(self['NW'] / 5.))
        self['FPOL'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
        offset = offset + nlNW
        self['PRES'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
        offset = offset + nlNW
        self['FFPRIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
        offset = offset + nlNW
        self['PPRIME'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
        offset = offset + nlNW
        try:
            # official gEQDSK file format saves PSIRZ as a single flat array of size rowsXcols
            nlNWNH = int(np.ceil(self['NW'] * self['NH'] / 5.))
            self['PSIRZ'] = np.reshape(np.fromiter(splitter(''.join(EQDSK[offset:offset + nlNWNH])), dtype=np.float),(self['NH'], self['NW']))
            offset = offset + nlNWNH
        except ValueError:
            # sometimes gEQDSK files save row by row of the PSIRZ grid (eg. FIESTA code)
            nlNWNH = self['NH'] * nlNW
            self['PSIRZ'] = np.reshape(np.fromiter(splitter(''.join(EQDSK[offset:offset + nlNWNH])), dtype=np.float),(self['NH'], self['NW']))
            offset = offset + nlNWNH
        self['QPSI'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
        offset = offset + nlNW

        # now vacuum vessel and limiters
        [self['NBBBS'], self['LIMITR']] = list(map(int, [_f for _f in EQDSK[offset:offset + 1][0].split(' ') if _f]))
        offset = offset + 1

        nlNBBBS = int(np.ceil(self['NBBBS'] * 2 / 5.))
        self['RBBBS'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNBBBS]))))[0::2])
        self['ZBBBS'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNBBBS]))))[1::2])
        offset = offset + max(nlNBBBS, 1)

        try:
            # this try/except is to handle some gEQDSK files written by older versions of ONETWO
            nlLIMITR = int(np.ceil(self['LIMITR'] * 2 / 5.))
            self['RLIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlLIMITR]))))[0::2])
            self['ZLIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlLIMITR]))))[1::2])
            offset = offset + nlLIMITR
        except ValueError:
            # if it fails make the limiter as a rectangle around the plasma boundary that does not exceed the computational domain
            self['LIMITR'] = 5
            dd = self['RDIM'] / 10.
            R = np.linspace(0, self['RDIM'], 2) + self['RLEFT']
            Z = np.linspace(0, self['ZDIM'], 2) - self['ZDIM'] / 2. + self['ZMID']
            self['RLIM'] = np.array([max([R[0], np.min(self['RBBBS']) - dd]),
                                        min([R[1], np.max(self['RBBBS']) + dd]),
                                        min([R[1], np.max(self['RBBBS']) + dd]),
                                        max([R[0], np.min(self['RBBBS']) - dd]),
                                        max([R[0], np.min(self['RBBBS']) - dd])])
            self['ZLIM'] = np.array([max([Z[0], np.min(self['ZBBBS']) - dd]),
                                        max([Z[0], np.min(self['ZBBBS']) - dd]),
                                        min([Z[1], np.max(self['ZBBBS']) + dd]),
                                        min([Z[1], np.max(self['ZBBBS']) + dd]),
                                        max([Z[0], np.min(self['ZBBBS']) - dd])])

    def addFluxSurfaces(self, **kw):
        """
        Adds ['fluxSurface'] to the current object
        :param \**kw: keyword dictionary passed to fluxSurfaces class
        :return: fluxSurfaces object based on the current gEQDSK file
        """
        if self['CURRENT'] == 0.0:
#            printw('Skipped tracing of fluxSurfaces for vacuum equilibrium')
            return

        options = {}
        options.update(kw)
        options['quiet'] = kw.pop('quiet', self['NW'] <= 129)
        options['levels'] = kw.pop('levels', True)
        options['resolution'] = kw.pop('resolution', 0)
        options['calculateAvgGeo'] = kw.pop('calculateAvgGeo', True)
        if 'CHEASE' in self['CASE'][0] or 'TRXPL' in self['CASE'][0]:
            options['forceFindSeparatrix'] = kw.pop('forceFindSeparatrix', False)
        else:
            options['forceFindSeparatrix'] = kw.pop('forceFindSeparatrix', True)

        try:
            self['fluxSurfaces'] = fluxSurfaces(gEQDSK=self, **options)
        except Exception as _excp:
            warnings.warn('Error tracing flux surfaces: ' + repr(_excp))
#            self['fluxSurfaces'] = OMFITerror('Error tracing flux surfaces: ' + repr(_excp))

        return self['fluxSurfaces']

    

#    @dynaLoad
#    def load(self, raw=False):
#        """
#        Method used to read g-files
#        :param raw: load gEQDSK exactly as it's on file, regardless of COCOS
#        """
#
#        if self.filename is None or not os.stat(self.filename).st_size:
#            return
#
#        # todo should be rewritten using FortranRecordReader
#        # based on w3.pppl.gov/ntcc/TORAY/G_EQDSK.pdf
##        def splitter(inv, step=16):
##            value = []
##            for k in range(int(len(inv) / step)):
##                value.append(inv[step * k:step * (k + 1)])
##            return value
##
##        def merge(inv):
##            return ''.join(inv)
#
#        self.clear()
#
#        # clean lines from the carriage returns
#        with open(self.filename, 'r') as f:
#            EQDSK = f.read().splitlines()
#
#        # first line is description and sizes
#        self['CASE'] = np.array(splitter(EQDSK[0][0:48], 8))
#        try:
#            tmp = list([_f for _f in EQDSK[0][48:].split(' ') if _f])
#            [IDUM, self['NW'], self['NH']] = list(map(int, tmp[:3]))
#        except ValueError: # Can happen if no space between numbers, such as 10231023
#            IDUM = int(EQDSK[0][48:52])
#            self['NW'] = int(EQDSK[0][52:56])
#            self['NH'] = int(EQDSK[0][56:60])
#            tmp = []
#            printd('IDUM, NW, NH',IDUM,self['NW'],self['NH'],topic='OMFITgeqdsk.load')
#        if len(tmp) > 3:
#            self['EXTRA_HEADER'] = EQDSK[0][49 + len(re.findall('%d +%d +%d ' % (IDUM, self['NW'], self['NH']), EQDSK[0][49:])[0]) + 2:]
#        offset = 1
#
#        # now, the next 20 numbers (5 per row)
#        [self['RDIM'], self['ZDIM'], self['RCENTR'], self['RLEFT'], self['ZMID'], \
#         self['RMAXIS'], self['ZMAXIS'], self['SIMAG'], self['SIBRY'], self['BCENTR'], \
#         self['CURRENT'], self['SIMAG'], XDUM, self['RMAXIS'], XDUM, \
#         self['ZMAXIS'], XDUM, self['SIBRY'], XDUM, XDUM] = list(map(eval, splitter(merge(EQDSK[offset:offset + 4]))))
#        offset = offset + 4
#
#        # now I have to read NW elements
#        nlNW = int(np.ceil(self['NW'] / 5.))
#        self['FPOL'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#        offset = offset + nlNW
#        self['PRES'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#        offset = offset + nlNW
#        self['FFPRIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#        offset = offset + nlNW
#        self['PPRIME'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#        offset = offset + nlNW
#        try:
#            # official gEQDSK file format saves PSIRZ as a single flat array of size rowsXcols
#            nlNWNH = int(np.ceil(self['NW'] * self['NH'] / 5.))
#            self['PSIRZ'] = np.reshape(np.fromiter(splitter(''.join(EQDSK[offset:offset + nlNWNH])), dtype=np.float),(self['NH'], self['NW']))
#            offset = offset + nlNWNH
#        except ValueError:
#            # sometimes gEQDSK files save row by row of the PSIRZ grid (eg. FIESTA code)
#            nlNWNH = self['NH'] * nlNW
#            self['PSIRZ'] = np.reshape(np.fromiter(splitter(''.join(EQDSK[offset:offset + nlNWNH])), dtype=np.float),(self['NH'], self['NW']))
#            offset = offset + nlNWNH
#        self['QPSI'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#        offset = offset + nlNW
#
#        # now vacuum vessel and limiters
#        [self['NBBBS'], self['LIMITR']] = list(map(int, [_f for _f in EQDSK[offset:offset + 1][0].split(' ') if _f]))
#        offset = offset + 1
#
#        nlNBBBS = int(np.ceil(self['NBBBS'] * 2 / 5.))
#        self['RBBBS'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNBBBS]))))[0::2])
#        self['ZBBBS'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNBBBS]))))[1::2])
#        offset = offset + max(nlNBBBS, 1)
#
#        try:
#            # this try/except is to handle some gEQDSK files written by older versions of ONETWO
#            nlLIMITR = int(np.ceil(self['LIMITR'] * 2 / 5.))
#            self['RLIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlLIMITR]))))[0::2])
#            self['ZLIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlLIMITR]))))[1::2])
#            offset = offset + nlLIMITR
#        except ValueError:
#            # if it fails make the limiter as a rectangle around the plasma boundary that does not exceed the computational domain
#            self['LIMITR'] = 5
#            dd = self['RDIM'] / 10.
#            R = np.linspace(0, self['RDIM'], 2) + self['RLEFT']
#            Z = np.linspace(0, self['ZDIM'], 2) - self['ZDIM'] / 2. + self['ZMID']
#            self['RLIM'] = np.array([max([R[0], np.min(self['RBBBS']) - dd]),
#                                        min([R[1], np.max(self['RBBBS']) + dd]),
#                                        min([R[1], np.max(self['RBBBS']) + dd]),
#                                        max([R[0], np.min(self['RBBBS']) - dd]),
#                                        max([R[0], np.min(self['RBBBS']) - dd])])
#            self['ZLIM'] = np.array([max([Z[0], np.min(self['ZBBBS']) - dd]),
#                                        max([Z[0], np.min(self['ZBBBS']) - dd]),
#                                        min([Z[1], np.max(self['ZBBBS']) + dd]),
#                                        min([Z[1], np.max(self['ZBBBS']) + dd]),
#                                        max([Z[0], np.min(self['ZBBBS']) - dd])])
#
#        try:
#            [self['KVTOR'], self['RVTOR'], self['NMASS']] = list(map(float,[_f for _f in EQDSK[offset:offset + 1][0].split(' ') if _f]))
#            offset = offset + 1
#
#            if self['KVTOR'] > 0:
#                self['PRESSW'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#                offset = offset + nlNW
#                self['PWPRIM'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#                offset = offset + nlNW
#
#            if self['NMASS'] > 0:
#                self['DMION'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#                offset = offset + nlNW
#
#            self['RHOVN'] = np.array(list(map(float, splitter(merge(EQDSK[offset:offset + nlNW])))))
#            offset = offset + nlNW
#        except Exception:
#            pass
#
#        # add RHOVN if missing
#        if 'RHOVN' not in self or not len(self['RHOVN']) or not np.sum(self['RHOVN']):
#            self.add_rhovn()
#
#        # fix some gEQDSK files that do not fill PRES info (eg. EAST)
#        if not np.sum(self['PRES']):
#            pres = integrate.cumtrapz(self['PPRIME'], np.linspace(self['SIMAG'], self['SIBRY'], len(self['PPRIME'])), initial=0)
#            self['PRES'] = pres - pres[-1]
#
#        # parse auxiliary namelist
#        self.addAuxNamelist()
#
#        if raw:
#            # add AuxQuantities and fluxSurfaces
#            self.addAuxQuantities()
#            self.addFluxSurfaces(**self.OMFITproperties)
#        else:
#            # Convert tree representation to COCOS 1
#            self._cocos = self.native_cocos()
#            self.cocosify(1, calcAuxQuantities=True, calcFluxSurfaces=True)
       
        
    
    
#### HERE down we didn't end up using    



def paraboloid(x, y, z):
    '''
    z = ax*x^2 + bx*x + ay*y^2 + by*y + c
    NOTE: This function uses only the first 5 points of the x, y, z arrays
    to evaluate the paraboloid coefficients
    :return: ax,bx,ay,by,c
    '''
    if np.any(np.isnan(x.flatten())) or np.any(np.isnan(y.flatten())) or np.any(np.isnan(z.flatten())):
        raise(np.linalg.LinAlgError('paraboloid could not be fit with x=%s y=%s z=%s'%(x,y,z)))
    A=[]
    for k in range(5):
        A.append([x[k]**2,x[k],y[k]**2,y[k],1])
    A=np.array(A)
    ax,bx,ay,by,c=np.dot(np.linalg.inv(A),np.array(z[:5]))
    return ax,bx,ay,by,c 

def contourPaths(x, y, Z, levels, remove_boundary_points=False, smooth_factor=1):
    '''
    :param x: 1D x coordinate
    :param y: 1D y coordinate
    :param Z: 2D data
    :param levels: levels to trace
    :param remove_boundary_points: remove traces at the boundary
    :param smooth_factor: smooth contours by cranking up grid resolution
    :return: list of segments
    '''
    import matplotlib
    if compare_version(matplotlib.__version__,'2.1')>=0:
        import matplotlib._contour as _contour
    else:
        from matplotlib import _cntr

    sf = int(round(smooth_factor))
    if sf > 1:
        x = scipy.ndimage.zoom(x, sf)
        y = scipy.ndimage.zoom(y, sf)
        Z = scipy.ndimage.zoom(Z, sf)

    [X,Y]=np.meshgrid(x,y)
    if compare_version(matplotlib.__version__,'2.1')>=0:
        contour_generator = _contour.QuadContourGenerator(X, Y, Z, None, True, 0)
    else:
        Cntr = matplotlib._cntr.Cntr(X,Y,Z)

    mx=min(x)
    Mx=max(x)
    my=min(y)
    My=max(y)

    allsegs = []
    for level in levels:
        if compare_version(matplotlib.__version__,'2.1')>=0:
            segs=contour_generator.create_contour(level)
        else:
            nlist = Cntr.trace(level)
            nseg = len(nlist)//2
            segs = nlist[:nseg]
        if not remove_boundary_points:
            segs_ = segs
        else:
            segs_ = []
            for segarray in segs:
                x_ = segarray[:,0]
                y_ = segarray[:,1]
                valid = []
                for i in range(len(x_)-1):
                    if np.isclose(x_[i],x_[i+1]) and (np.isclose(x_[i],Mx) or np.isclose(x_[i],mx)):
                        continue
                    if np.isclose(y_[i],y_[i+1]) and (np.isclose(y_[i],My) or np.isclose(y_[i],my)):
                        continue
                    valid.append((x_[i],y_[i]))
                    if i==len(x_):
                        valid.append(x_[i+1],y_[i+1])
                if len(valid):
                    segs_.append(np.array(valid))

        segs=list(map(matplotlib.path.Path,segs_))
        allsegs.append(segs)
    return allsegs

       
    
class fluxSurfaces(dict):
    '''
    Trace flux surfaces and calculate flux-surface averaged and geometric quantities
    Inputs can be tables of PSI and Bt or an OMFITgeqdsk file
    '''
    def __init__(self, Rin=None, Zin=None, PSIin=None, Btin=None, Rcenter=None, F=None, P=None, rlim=None, zlim=None,
                 gEQDSK=None,
                 resolution=0, forceFindSeparatrix=True, levels=None, map=None, maxPSI=1.0,
                 calculateAvgGeo=True,
                 cocosin=None,
                 quiet=False,
                 **kw):
        '''
        :param Rin: (ignored if gEQDSK!=None) array of the R grid mesh
        :param Zin: (ignored if gEQDSK!=None) array of the Z grid mesh
        :param PSIin: (ignored if gEQDSK!=None) PSI defined on the R/Z grid
        :param Btin: (ignored if gEQDSK!=None) Bt defined on the R/Z grid
        :param Rcenter: (ignored if gEQDSK!=None) Radial location where the vacuum field is defined ( B0 = F[-1] / Rcenter)
        :param F: (ignored if gEQDSK!=None) F-poloidal
        :param P: (ignored if gEQDSK!=None) pressure
        :param rlim: (ignored if gEQDSK!=None) array of limiter r points (used for SOL)
        :param zlim: (ignored if gEQDSK!=None) array of limiter z points (used for SOL)
        :param gEQDSK: OMFITgeqdsk file or ODS
        :param resolution: if `int` the original equilibrium grid will be multiplied by (resolution+1), if `float` the original equilibrium grid is interpolated to that resolution (in meters)
        :param forceFindSeparatrix: force finding of separatrix even though this may be already available in the gEQDSK file
        :param levels: levels in normalized psi. Can be an array ranging from 0 to 1, or the number of flux surfaces
        :param map: array ranging from 0 to 1 which will be used to set the levels, or 'rho' if flux surfaces are generated based on gEQDSK
        :param maxPSI: (default 0.9999)
        :param calculateAvgGeo: Boolean which sets whether flux-surface averaged and geometric quantities are automatically calculated
        :param quiet: Verbosity level
        :param \**kw: overwrite key entries
        >> OMFIT['test']=OMFITgeqdsk(OMFITsrc+'/../samples/g133221.01000')
        >> # copy the original flux surfaces
        >> flx=copy.deepcopy(OMFIT['test']['fluxSurfaces'])
        >> # to use PSI
        >> mapping=None
        >> # to use RHO instead of PSI
        >> mapping=OMFIT['test']['RHOVN']
        >> # trace flux surfaces
        >> flx.findSurfaces(linspace(0,1,100),mapping=map)
        >> # to increase the accuracy of the flux surface tracing (higher numbers --> smoother surfaces, more time, more memory)
        >> flx.changeResolution(2)
        >> # plot
        >> flx.plot()
        '''
        self.quiet=quiet
        self.forceFindSeparatrix = forceFindSeparatrix
        self.calculateAvgGeo = calculateAvgGeo
        self.levels=levels
        self.resolution=resolution

       
        self.cocosin = gEQDSK.cocos
        if not self.quiet:
            print('Flux surfaces from %dx%d gEQDSK'%(gEQDSK['NW'],gEQDSK['NH']))
        self.Rin       = np.linspace(0,gEQDSK['RDIM'], gEQDSK['NW']) + gEQDSK['RLEFT']
        self.Zin       = np.linspace(0,gEQDSK['ZDIM'], gEQDSK['NH']) - gEQDSK['ZDIM']/2. + gEQDSK['ZMID']
        self.PSIin     = gEQDSK['PSIRZ']
        self.F         = gEQDSK['FPOL']
        self.P         = gEQDSK['PRES']
        self.FFPRIM    = gEQDSK['FFPRIM']
        self.PPRIME    = gEQDSK['PPRIME']
        self.Btin      = gEQDSK['AuxQuantities']['Bt']
        self['R0']     = gEQDSK['RMAXIS']
        self['Z0']     = gEQDSK['ZMAXIS']
        self['RCENTR'] = gEQDSK['RCENTR']
        self.sep       = np.vstack((gEQDSK['RBBBS'], gEQDSK['ZBBBS'])).T
        self.open_sep  = None
        self.PSIaxis   = gEQDSK['SIMAG']
        self.flx       = gEQDSK['SIBRY']
        self.rlim      = gEQDSK['RLIM']
        self.zlim      = gEQDSK['ZLIM']

        # At the end of the following section:
        # forceFindSeparatrix = None means that existing separatrix is likely to be ok
        # forceFindSeparatrix = True means that new separtrix should be found
        # forceFindSeparatrix = False means that old separtrix should be left alone
        if forceFindSeparatrix is None:
            psiSep = RectBivariateSplineNaN(self.Zin, self.Rin, self.PSIin).ev(gEQDSK['ZBBBS'],gEQDSK['RBBBS'])
            cost=np.sqrt(np.var(psiSep))/abs(self.flx)
            if cost > 1.E-2 and self.forceFindSeparatrix is None:
                self.forceFindSeparatrix = 'check'
            if cost > 5.E-2:
                print("Normalized variance of PSI at separatrix ['RBBBS'],['ZBBBS'] points is "+format(cost*100,'6.3g')+'%')
                self.forceFindSeparatrix = True
            cost=abs((self.flx-np.mean(psiSep))/(self.flx-self.PSIaxis))
            if cost > 1.E-2 and self.forceFindSeparatrix is None:
                self.forceFindSeparatrix = 'check'
            if cost > 5.E-2:
                print("Relative error between ['SIBRY'] and average value of PSI at separatrix ['RBBBS'],['ZBBBS'] points is "+format(cost*100,'6.3g')+'%')
                self.forceFindSeparatrix = True
            if self.PSIaxis<self.flx:
                self.flx=min(psiSep)
            if self.PSIaxis>self.flx:
                self.flx=max(psiSep)

        #setup level mapping
        if isinstance(map,basestring):
            if map=='rho' and gEQDSK is not None:
                self.map=gEQDSK['RHOVN']
                if not self.quiet: printi('Levels based on rho ...')
            else:
                self.map=None
                if not self.quiet: printi('Levels based on psi ...')
        elif map is not None:
            if not self.quiet: printi('Levels based on user provided map ...')
            self.map=map
        else:
            self.map=None
            if not self.quiet: printi('Levels based on psi ...')

        self.maxPSI=maxPSI

        self.update(kw)



        self._changeResolution(self.resolution)

        self._crop()
        self._findAxis()

        if self.forceFindSeparatrix is not False:
            if self.forceFindSeparatrix == 'check':
                # check if the flux surface at PSI=1 (using the original PSI definition) is actually valid
                if not len(self._findSurfaces(levels=[1.0])):
                    printi('Forcing find of new separatrix!')
                    self.quiet=False
                    self.forceFindSeparatrix=True
            if self.forceFindSeparatrix is True:
                self._findSeparatrix()

        if self.levels is not None:
            self.findSurfaces(self.levels)

    def _findAxis(self):
        if not self.quiet:
            printi('Find magnetic axis ...')
        if not hasattr(self, 'R'):
            self._changeResolution(0)
        if 'R0' not in self or 'Z0' not in self:
            # limit search of the axis to a circle centered in the center of the domain
            Raxis = (self.R[0] + self.R[-1]) / 2.0
            Zaxis = (self.Z[0] + self.Z[-1]) / 2.0
        else:
            Raxis = self['R0']
            Zaxis = self['Z0']
        dmax = (self.R[-1] - self.R[0]) / 2.0 / 1.5

        RR, ZZ = np.meshgrid(self.R - Raxis, self.Z - Zaxis)
        DD = np.sqrt(RR ** 2 + ZZ ** 2) < dmax
        tmp = self.PSI.copy()
        tmp[np.where(DD == 0)] = np.nan

        # figure out sign
        ax = 0
        for k in range(1, int(min([ int(len(self.R) // 2), int(len(self.Z) // 2)])))[::-1]:
            ri = (int(len(self.R) // 2) + np.array([-k, 0, +k, 0, 0])).astype(int)
            zi = (int(len(self.Z) // 2) + np.array([0, 0, 0, +k, -k])).astype(int)
            try:
                ax, bx, ay, by, c = paraboloid(self.R[ri], self.Z[zi], tmp[zi, ri])
                break
            except np.linalg.LinAlgError:
                pass
        if ax > 0:
            # look for the minimum
            m = np.nanargmin(tmp)
        else:
            # look for the maximum
            m = np.nanargmax(tmp)
        Zmi = int(m / self.PSI.shape[1])
        Rmi = int(m - Zmi * self.PSI.shape[1])

        # pick center points based on the grid
        self.PSIaxis = self.PSI[Zmi, Rmi]
        self['R0'] = self.R[Rmi]
        self['Z0'] = self.Z[Zmi]

        # fit paraboloid in the vicinity of the grid-based center
        ri = (Rmi + np.array([-1, 0, +1, 0, 0])).astype(int)
        zi = (Zmi + np.array([0, 0, 0, +1, -1])).astype(int)
        ax, bx, ay, by, c = paraboloid(self.R[ri], self.Z[zi], self.PSI[zi, ri])
        self['R0_interp'] = -bx / (2 * ax)
        self['Z0_interp'] = -by / (2 * ay)

        # forceFindSeparatrix also controls whether PSI on axis should be redefined
        if self.forceFindSeparatrix is not False:
            # set as the center value of PSI (based on R0 and Z0)
            PSIaxis_found = RectBivariateSplineNaN(self.Z, self.R, self.PSI).ev(self['Z0_interp'], self['R0_interp'])
            if self.PSIaxis is None:
                self.PSIaxis = self.PSI[Zmi, Rmi]
            elif self.flx is not None:
                self.PSI = (self.PSI - PSIaxis_found) / abs(self.flx - PSIaxis_found) * abs(self.flx - self.PSIaxis) + self.PSIaxis

        # understand sign of the current based on curvature of psi
        if not hasattr(self, 'sign_Ip'):
            self.sign_Ip = np.sign(ax) * self._cocos['sigma_Bp']
        # tmp[isnan(tmp)]=5
        # contour(self.Rin,self.Zin,tmp)
        # plot(self['R0'],self['Z0'],'or')
        # plot(self['R0_interp'],self['Z0_interp'],'ob')

    def _findSurfaces(self, levels, usePSI=False):
        signTheta = self._cocos['sigma_RpZ']*self._cocos['sigma_rhotp']  # +! is clockwise
        if not hasattr(self,'PSI'):
            self._changeResolution(self.resolution)
        if usePSI:
            levels_psi=np.array(levels)
            levels=(levels_psi-self.PSIaxis)/((self.flx - self.PSIaxis)*self.maxPSI)
        else:
            levels_psi=np.array(levels)*(self.flx - self.PSIaxis)*self.maxPSI+self.PSIaxis
        CS=contourPaths(self.R,self.Z,self.PSI,levels_psi)
        lines=dict()
        for k,item1 in enumerate(CS):
            line=[]
            if levels_psi[k]==self.PSIaxis:
                #axis
                line=np.array([self['R0'],self['Z0']]).reshape((1,2))
            elif len(item1):
                #all others
                index=np.argsort([len(k1.vertices) for k1 in item1])
                if item1[-1] in index:
                    index.insert(0,index.pop(item1[-1]))
                for k1 in index:
                    path=item1[k1]
                    r=path.vertices[:,0]
                    z=path.vertices[:,1]
                    if any(np.isnan(r*z)):
                        continue
                    r[0]=r[-1]=(r[0]+r[-1])*0.5
                    z[0]=z[-1]=(z[0]+z[-1])*0.5
                    t=np.unwrap(np.arctan2(z-self['Z0'],r-self['R0']))
                    t-=np.mean(t)
                    l=np.linspace(0,1,len(t))
                    X=max(abs(integrate.cumtrapz(integrate.cumtrapz(t,l,initial=0),l)))
                    if not len(line) or X>Xmax:
                        orientation = int(np.sign((z[0]-self['Z0'])*(r[1]-r[0])-(r[0]-self['R0'])*(z[1]-z[0])))
                        if orientation != 0:
                            line=path.vertices[::signTheta*orientation,:]
                        else:
                            line=path.vertices
                        Xmax=X

            lines[levels[k]]=line
        del self.PSI
        del self.R
        del self.Z
        return lines

    @dynaLoad
    def findSurfaces(self, levels=None, map=None):
        '''
        Find flux surfaces at levels
        :param levels: defines at which levels the flux surfaces will be traced
        * None: use levels defined in gFile
        * Integer: number of levels
        * list: list of levels to find surfaces at
        :param map: psi mapping on which levels are defined (e.g. rho as function of psi)
        '''
        signTheta = self._cocos['sigma_RpZ']*self._cocos['sigma_rhotp']  # +! is clockwise
        t0 = datetime.datetime.now()
        if not hasattr(self,'sep'):
            self._findSeparatrix()
        if np.iterable(levels):
            levels=list(levels)
            levels.sort()
        elif isinstance(levels,int) and not isinstance(levels,bool):
            levels=list(np.linspace(0,1,int(levels)))
        else:
            if 'levels' not in self:
                levels=list(np.linspace(0,1,len(self.Rin)))
            else:
                levels=self['levels']

        if map is not None:
            self.map=map
        if self.map is not None:
            levels=scipy.interpolate.PchipInterpolator(self.map,np.linspace(0,1,self.map.size),extrapolate=True)(levels).tolist()
            levels[0]=0.
            levels[-1]=1.

        if not self.quiet:
            printi('Tracing flux surfaces ...')

        levels_psi=np.array(levels)*(self.flx - self.PSIaxis)*self.maxPSI+self.PSIaxis
        lines=self._findSurfaces(levels)

        self['levels']=np.zeros((len(levels)))
        self['flux']=fluxSurfaceTraces()
        self.nc=0

        for k,item1 in reverse_enumerate(lines.keys()):
            self['flux'][k]=SortedDict()
            self['flux'][k]['psi']=levels_psi[k]
            self['levels'][k]=levels[k]

            line=lines[item1]

            if k==0:
                #axis
                imaxr = np.argmax(self['flux'][k+1]['R'])
                z_at_max_r,max_r  = parabolaMaxCycle(self['flux'][k+1]['Z'],self['flux'][k+1]['R'],imaxr)

                iminr = np.argmin(self['flux'][k+1]['R'])
                z_at_min_r,min_r  = parabolaMaxCycle(self['flux'][k+1]['Z'],self['flux'][k+1]['R'],iminr)

                imaxz = np.argmax(self['flux'][k+1]['Z'])
                r_at_max_z,max_z  = parabolaMaxCycle(self['flux'][k+1]['R'],self['flux'][k+1]['Z'],imaxz)

                iminz = np.argmin(self['flux'][k+1]['Z'])
                r_at_min_z,min_z  = parabolaMaxCycle(self['flux'][k+1]['R'],self['flux'][k+1]['Z'],iminz)

                a   = 0.5*( max_r - min_r )
                kap = 0.5*( ( max_z - min_z )/ a )

                simplePath=matplotlib.path.Path(np.vstack((self['flux'][k+1]['R'],self['flux'][k+1]['Z'])).T)
                if simplePath.contains_point((self['R0_interp'],self['Z0_interp'])):
                    self['R0']=self['R0_interp']
                    self['Z0']=self['Z0_interp']

                r=a*1E-3
                t=np.linspace(0,2*np.pi,len(self['flux'][k+1]['R']))

                self['flux'][k]['R']=r*np.cos(t)+self['R0']
                self['flux'][k]['Z']=-signTheta*kap*r*np.sin(t)+self['Z0']

            else:
                #all others
                if len(line):
                    self['flux'][k]['R']=line[:,0]
                    self['flux'][k]['Z']=line[:,1]
                elif hasattr(self,'sep') and k==len(levels)-1 :
                    #If you are here, it is because the EFIT separatrix turned out to be not so precise
                    printi('Forcing find of new separatrix!')
                    self._findSeparatrix()
                    self['flux'][k]['R']=self.sep[:,0]
                    self['flux'][k]['Z']=self.sep[:,1]
                else:
                    printw('Bad flux surface! #'+str(k)+" This is likely to be a bad equilibrium, which does not satisfy Grad-Shafranov...")
                    #plot(path.vertices[:,0],path.vertices[:,1],'b')
                    #plot(self.sep[:,0],self.sep[:,1],'r')
                    self['flux'][k]['R']=self['flux'][k+1]['R'].copy()
                    self['flux'][k]['Z']=self['flux'][k+1]['Z'].copy()
            self.nc+=1

        self['flux'].sort()

        # if lcfs does not close it's likely because we trusted external value of flux surface flux (e.g. from gEQDSK)
        # so we need to force re-finding of flux surfaces
        if (self['flux'][self.nc-1]['R'][0]!=self['flux'][self.nc-1]['R'][-1]) | (self['flux'][self.nc-1]['Z'][0]!=self['flux'][self.nc-1]['Z'][-1]):
            self.changeResolution(self.resolution)

        if not self.quiet: printi('  > Took {:}'.format(datetime.datetime.now() - t0))
        #These quantities can take a lot of space, depending on the resolution
        #They are deleted, and if necessary re-generated on demand
        self.surfAvg()

    def _changeResolution(self, resolution):
        #PSI is the table on which flux surfaces are generated, by increasing it's resolution,
        #the contour path becomes more and more smooth. This much better than doing a spline interpolation through
        #a rough path.
        self.resolution=resolution
        if self.resolution == 0:
            self.R=self.Rin
            self.Z=self.Zin
            self.PSI=self.PSIin
        elif isinstance(self.resolution,int):
            if self.resolution>0:
                if not self.quiet: printi('Increasing tables resolution by factor of '+str(abs(self.resolution)+1)+' ...')
                nr=len(self.Rin)
                nz=len(self.Zin)
                for k in range(self.resolution):
                    nr=nr+nr-1
                    nz=nz+nz-1
                self.R=np.linspace(min(self.Rin),max(self.Rin),nr)
                self.Z=np.linspace(min(self.Zin),max(self.Zin),nz)
                self.PSI=RectBivariateSplineNaN(self.Zin, self.Rin, self.PSIin)(self.Z,self.R)
            elif self.resolution<0:
                if not self.quiet: printi('Decreasing tables resolution by factor of '+str(abs(self.resolution)+1)+' ...')
                self.R=self.Rin[::-self.resolution]
                self.Z=self.Zin[::-self.resolution]
                self.PSI=self.PSIin[::-self.resolution,::-self.resolution]
        elif isinstance(self.resolution,float):
            if not self.quiet: printi('Interpolating tables to '+str(self.resolution)+' m resolution ...')
            self.R=np.linspace(min(self.Rin),max(self.Rin),np.ceil((max(self.Rin)-min(self.Rin))/self.resolution))
            self.Z=np.linspace(min(self.Zin),max(self.Zin),np.ceil((max(self.Zin)-min(self.Zin))/self.resolution))
            self.PSI=RectBivariateSplineNaN(self.Zin, self.Rin, self.PSIin)(self.Z,self.R)

        self.dd=np.sqrt((self.R[1]-self.R[0])**2+(self.Z[1]-self.Z[0])**2)
        if not self.quiet: printi('Grid diagonal resolution: '+str(self.dd)+' m')

    @dynaLoad
    def changeResolution(self, resolution):
        '''
        :param resolution: resolution to use when tracing flux surfaces
        * integer: multiplier of the original table
        * float: grid resolution in meters
        '''
        self._changeResolution(resolution)
        self._crop()
        self._findAxis()
        self._findSeparatrix()
        self.findSurfaces()

    def _findSeparatrix(self, accuracy=6):
        #separatrix is found by looking for the largest closed path enclosing the magnetic axis
        signTheta = self._cocos['sigma_RpZ']*self._cocos['sigma_rhotp']  # +! is clockwise
        if not hasattr(self,'PSI'):
            self._changeResolution(self.resolution)
        if not self.quiet: printi('Find separatrix ...')

        if self.sign_Ip*self._cocos['sigma_Bp']>0:
            # PSI increases to axis
            flxm=np.nanmin(self.PSI)
            flxM=np.nanmax(self.PSI)
        else:
            flxm=np.nanmax(self.PSI)
            flxM=np.nanmin(self.PSI)

        #plot(self['R0'],self['Z0'],'or') #<< DEBUG axis

        kdbgmax=100
        flx_found = None
        for kdbg in range(kdbgmax):

            flx=(flxM+flxm)/2.

            line=[]
            paths=contourPaths(self.R,self.Z,self.PSI,[flx])[0]
            for path in paths:
                if not np.isnan(path.vertices[:]).any() and np.allclose(path.vertices[0,0],path.vertices[-1,0]) and np.allclose(path.vertices[0,1],path.vertices[-1,1]):
                    path.vertices[0, 0] = path.vertices[-1, 0] = (path.vertices[0, 0] + path.vertices[-1, 0]) * 0.5
                    path.vertices[0, 1] = path.vertices[-1, 1] = (path.vertices[0, 1] + path.vertices[-1, 1]) * 0.5
                    simplePath=matplotlib.path.Path(path.vertices[::int(len(path.vertices[:,0])//10+1),:])
                    if np.max(simplePath.vertices[:,0])>self['R0'] and np.min(simplePath.vertices[:,0])<self['R0'] and  np.max(simplePath.vertices[:,1])>self['Z0'] and min(simplePath.vertices[:,1])<self['Z0']:
                        if simplePath.contains_point((self['R0'],self['Z0'])):
                            dR = path.vertices[1,0]-path.vertices[0,0]
                            dZ = path.vertices[1,1]-path.vertices[0,1]
                            orientation = int(np.sign((path.vertices[0,1]-self['Z0'])*dR-(path.vertices[0,0]-self['R0'])*dZ))
                            line=line=path.vertices[::signTheta*orientation,:]
                            break

            if len(line):
                #plot(line[:,0],line[:,1],'r') #<< DEBUG plot, showing convergence
                try:
                    # stop condition
                    np.testing.assert_array_almost_equal(sep/self['R0'],line/self['R0'],accuracy)
                    break
                except Exception:
                    pass
                finally:
                    sep = line
                    flx_found = flx
                    flxm = flx

            else:
                open_sep=paths
                flxM=flx
                #for path in paths:
                #    plot(path.vertices[:,0],path.vertices[:,1],'b') #<< DEBUG plot, showing convergence

        # do not store new separatrix if it hits edges of computation domain
        if ((np.abs(np.min(sep[:, 0]) - np.min(self.R)) < 1E-3) or
            (np.abs(np.max(sep[:, 0]) - np.max(self.R)) < 1E-3) or
            (np.abs(np.min(sep[:, 1]) - np.min(self.Z)) < 1E-3) or
            (np.abs(np.max(sep[:, 1]) - np.max(self.Z)) < 1E-3)):
            self.forceFindSeparatrix = False

        else:
            self.sep = sep
            self.open_sep = open_sep

            #printd(flxm,flxM,flx,flxm-flxM,kdbg) #<< DEBUG print, showing convergence

            if self.flx is None:
                self.flx = flx_found
            elif self.PSIaxis is not None:
                self.PSI = (self.PSI - self.PSIaxis) / abs(flx_found - self.PSIaxis) * abs(self.flx - self.PSIaxis) + self.PSIaxis

            if self.open_sep:
                outer_midplane_distance=[]
                for k,path in enumerate(self.open_sep):
                    ix=np.where(path.vertices[:,0]>self['R0'])[0]
                    if not len(ix):
                        outer_midplane_distance.append(np.inf)
                        continue
                    outer_midplane_distance.append(min(abs(path.vertices[ix,1]-self['Z0'])))
                ix=np.argmin(outer_midplane_distance)
                #plot(self.open_sep[ix].vertices[:,0],self.open_sep[ix].vertices[:,1],'m') #<< DEBUG plot, showing open field separatrix
                self.open_sep=self.open_sep[ix].vertices

        if kdbg==kdbgmax-1:
            printw('Finding of last closed flux surface aborted after %d iterations!!!'%kdbgmax)

    def _calcBrBz(self):
        RR, ZZ = np.meshgrid(self.Rin, self.Zin)
        [dPSIdZ, dPSIdR] = np.gradient(self.PSIin, self.Zin[1]-self.Zin[0], self.Rin[1]-self.Rin[0])
        Br = self._cocos['sigma_RpZ']*self._cocos['sigma_Bp']*dPSIdZ/(RR*((2*np.pi)**self._cocos['exp_Bp']))
        Bz = -self._cocos['sigma_RpZ']*self._cocos['sigma_Bp']*dPSIdR/(RR*((2*np.pi)**self._cocos['exp_Bp']))
        return Br,Bz

    def _BrBzAndF(self):
        t0 = datetime.datetime.now()
        if not self.quiet: printi('Find Br, Bz, F on flux surfaces ...')

        RR, ZZ = np.meshgrid(self.Rin, self.Zin)

        #F=Bt*R is a flux surface quantity
        if not hasattr(self,'F'):
            #if F is not present, find it through the Btin table
            F=self._surfMean(self.Btin*RR)
        else:
            #if F is present
            F=interpolate.InterpolatedUnivariateSpline(np.linspace(0,1,self.F.size),self.F)(self['levels'])
        for k in range(self.nc):
            self['flux'][k]['F']=F[k]

        if self['RCENTR'] is None:
            printw('Using magnetic axis as RCENTR of vacuum field ( BCENTR = Fpol[-1] / RCENTR)')
            self['RCENTR'] = self['R0']
        self['BCENTR'] = self['flux'][self.nc-1]['F'] / self['RCENTR']

        #if P is present
        if hasattr(self,'P'):
            P=interpolate.InterpolatedUnivariateSpline(np.linspace(0,1,self.P.size),self.P)(self['levels'])
            for k in range(self.nc):
                self['flux'][k]['P']=P[k]

        #if PPRIME is present
        if hasattr(self,'PPRIME'):
            PPRIME=interpolate.InterpolatedUnivariateSpline(np.linspace(0,1,self.PPRIME.size),self.PPRIME)(self['levels'])
            for k in range(self.nc):
                self['flux'][k]['PPRIME']=PPRIME[k]

        #if FFPRIM is present
        if hasattr(self,'FFPRIM'):
            FFPRIM=interpolate.InterpolatedUnivariateSpline(np.linspace(0,1,self.FFPRIM.size),self.FFPRIM)(self['levels'])
            for k in range(self.nc):
                self['flux'][k]['FFPRIM']=FFPRIM[k]


        #calculate Br and Bz magnetic fields
        Br, Bz = self._calcBrBz()

        [dBrdZ, dBrdR] = np.gradient(Br, self.Zin[2]-self.Zin[1], self.Rin[2]-self.Rin[1])
        [dBzdZ, dBzdR] = np.gradient(Bz, self.Zin[2]-self.Zin[1], self.Rin[2]-self.Rin[1])
        [dBtdZ, dBtdR] = np.gradient(self.Btin, self.Zin[2]-self.Zin[1], self.Rin[2]-self.Rin[1])
        [dRBtdZ, dRBtdR] = np.gradient(RR*self.Btin, self.Zin[2]-self.Zin[1], self.Rin[2]-self.Rin[1])
        Jt = self._cocos['sigma_RpZ']*(dBrdZ-dBzdR)/(4*np.pi*1E-7)


        #calculate flux expansion
        Brfun = RectBivariateSplineNaN(self.Zin, self.Rin, Br)
        Bzfun = RectBivariateSplineNaN(self.Zin, self.Rin, Bz)
        Jtfun = RectBivariateSplineNaN(self.Zin, self.Rin, Jt)
        self.fluxexpansion=[]
        self.dl=[]
        self.fluxexpansion_dl=[]
        self.int_fluxexpansion_dl=[]
        for k in range(self.nc):
            #self.dl.append( np.sqrt( np.gradient(self['flux'][k]['R'])**2 + np.gradient(self['flux'][k]['Z'])**2) )
            self.dl.append( np.sqrt( np.ediff1d(self['flux'][k]['R'],to_begin=0.)**2 + np.ediff1d(self['flux'][k]['Z'],to_begin=0.)**2) )
            self['flux'][k]['Br']=Brfun.ev(self['flux'][k]['Z'],self['flux'][k]['R'])
            self['flux'][k]['Bz']=Bzfun.ev(self['flux'][k]['Z'],self['flux'][k]['R'])
            modBp=np.sqrt(self['flux'][k]['Br']**2+self['flux'][k]['Bz']**2)
            self.fluxexpansion.append(1/modBp)
            self.fluxexpansion_dl.append(self.fluxexpansion[k]*self.dl[k])
            self.int_fluxexpansion_dl.append(np.sum(self.fluxexpansion_dl[k]))
            self['flux'][k]['Jt']=Jtfun.ev(self['flux'][k]['Z'],self['flux'][k]['R'])

        self.int_fluxexpansion_dl=np.array(self.int_fluxexpansion_dl)
        self.fluxexpansion_dl=np.array(self.fluxexpansion_dl)
        self.fluxexpansion=np.array(self.fluxexpansion)
        self.dl=np.array(self.dl)
        if not self.quiet: printi('  > Took {:}'.format(datetime.datetime.now() - t0))

    def _crop(self):
        if self.rlim is not None and self.zlim is not None and len(self.rlim) and len(self.zlim):
            if not self.quiet: printi('Cropping tables ...')
            if self.rlim is not None and self.zlim is not None:
                if any(np.isnan(self.rlim)) or any(np.isnan(self.zlim)):
                    printw('fluxsurfaces: rlim/zlim arrays contain NaNs')
                    return
            bbox=[min(self.rlim),max(self.rlim),min(self.zlim),max(self.zlim)]
            limits=[max([np.argmin(abs(self.R-bbox[0]))-1,0]),
                    min([np.argmin(abs(self.R-bbox[1]))+1,len(self.R)-1]),
                    max([np.argmin(abs(self.Z-bbox[2]))-1,0]),
                    min([np.argmin(abs(self.Z-bbox[3]))+1,len(self.Z)-1])]
            self.PSI=self.PSI[limits[2]:limits[3],limits[0]:limits[1]]
            self.R=self.R[limits[0]:limits[1]]
            self.Z=self.Z[limits[2]:limits[3]]

    @dynaLoad
    def resample(self, np=None, technique='uniform', phase='Xpoint'):
        '''
        resample number of points on flux surfaces
        :param np: number of points
        :param technique: 'uniform','separatrix','pest'
        :param phase: float for poloidal angle or 'Xpoint'
        '''
        if np is None or np.iterable(np):
            np=self.sep.size
        if technique=='separatrix':
            self._resample()
        elif technique=='uniform':
            self._resample(np,phase)
        elif technique=='pest':
            th=self._straightLineTheta(np)
            self._resample(th,phase)
        self._BrBzAndF()
        self.surfAvg()

    def _resample(self, np=None, phase='Xpoint'):
        """Resampling will lead inaccuracies of the order of the resolution on which the flux surface tracing was originally done"""

        signTheta = self._cocos['sigma_RpZ']*self._cocos['sigma_rhotp']  # +! is clockwise

        #pyplot.subplot(1,1, 1, aspect='equal')
        if not self.quiet: printi('Resampling flux surfaces ...')
        if np is None:
            #maintain angles, direction and angle of separatrix
            theta0=-signTheta*np.arctan2(self.sep[:,1]-self['Z0'],self.sep[:,0]-self['R0'])
            thetaXpoint=theta0[0]
            per_=1
        else:
            if phase=='Xpoint':
                # X-point as the location of minimum Bp along the separatrix
                #indexXpoint=np.argmin(RectBivariateSplineNaN(self.Zin, self.Rin, self.Bpin).ev(self.sep[:,1],self.sep[:,0]))
                #thetaXpoint=np.arctan2(self.sep[indexXpoint,1]-self['Z0'],self.sep[indexXpoint,0]-self['R0'])
                # X-point as the location of minimum angle between two adjacent segments of the separatrix
                a=np.vstack((np.gradient(self.sep[:-1,0]),np.gradient(self.sep[:-1,1]))).T
                b=np.vstack((np.gradient(np.hstack((self.sep[1:-1,0],self.sep[0,0]))),np.gradient(np.hstack((self.sep[1:-1,1],self.sep[0,1]))))).T
                gr=(a[:,0]*b[:,0]+a[:,1]*b[:,1])/np.sqrt(np.sum(a**2,1))/np.sqrt(np.sum(b**2,1))
                t=-signTheta*np.arctan2(self.sep[:,1]-self['Z0'],self.sep[:,0]-self['R0'])
                thetaXpoint=t[np.argmin(gr)]
                per_=0
            else:
                thetaXpoint=phase
                per_=1
            if not np.iterable(np):
                theta0=np.linspace(0,2*np.pi,np)+thetaXpoint

        for k in range(self.nc):

            if self['levels'][k]==1:
                per=per_
            else:
                per=1

            t=np.unwrap(-signTheta*np.arctan2(self['flux'][k]['Z']-self['Z0'],self['flux'][k]['R']-self['R0']))

            if np.iterable(np):
                if np.iterable(np[0]):
                    theta0=np[k]
                else:
                    theta0=np

            # force 'X axis' to be monotonically increasing
            if t[0]>t[1]:
                t=-t
                theta=-theta0
            else:
                theta=theta0

            index=np.argsort((theta[:-1]+thetaXpoint)%(2*np.pi)-thetaXpoint)
            index=np.hstack((index,index[0]))
            theta=np.unwrap(theta[index])

            index=np.argsort((t[:-1]+thetaXpoint)%(2*np.pi)-thetaXpoint)
            index=np.hstack((index,index[0]))

            t=np.unwrap(t[index])
            for item in ['R','Z','Br','Bz']:
                if item in self['flux'][k]:
                    self['flux'][k][item]=self['flux'][k][item][index]
                    #these quantities are periodic (per=1), however per=0 can be used to allow discontinuity of derivatives at X-point
                    tckp=interpolate.splrep(t ,self['flux'][k][item],k=3,per=1) #per=per)
                    self['flux'][k][item] = interpolate.splev( (theta-t[0])%max(t-t[0])+t[0] ,tckp,ext=0)
                    self['flux'][k][item][-1]=self['flux'][k][item][0]

    def _straightLineTheta(self, np=None):
        signTheta = self._cocos['sigma_RpZ']*self._cocos['sigma_rhotp']
        if not self.quiet: printi('Evaluating straight line theta ...')
        if 'avg' not in self:
            self.surfAvg()
        theta=[]
        for k in range(self.nc):
            if np is None:
                np_=self['flux'][k]['R'].size
            else:
                np_=np

            #t_ is the uniformly sampled straigthline theta
            t_=np.linspace(0,2*np.pi,np_)

            if self['levels'][0]==0 and k==0:
                theta.append(t_)
            else:
                #thetaStraight is the calculated straigthline theta
                signBp = signTheta*np.sign((self['flux'][k]['Z']-self['Z0'])*self['flux'][k]['Br']-(self['flux'][k]['R']-self['R0'])*self['flux'][k]['Bz'])
                Bp=signBp*np.sqrt(self['flux'][k]['Br']**2+self['flux'][k]['Bz']**2)
                Bt=self['flux'][k]['F']/self['flux'][k]['R']
                thetaStraight=np.unwrap(np.cumsum(self.dl[k]*Bt/(abs(Bp)*self['avg']['q'][k]*self['flux'][k]['R'])))
                #t is the real theta angle
                t=np.unwrap(-signTheta*np.arctan2(self['flux'][k]['Z']-self['Z0'],self['flux'][k]['R']-self['R0']))

                #enforce 'X axis' (thetaStraight) to be monotonically increasing
                if thetaStraight[0]>thetaStraight[1]:
                    thetaStraight=-thetaStraight
                if t[0]>t[1]:
                    t=-t

                #to use periodic spline I need to make my 'y' periodic, this is done by defining tDelta, that is the difference
                #between the straigthline and the real theta
                tDelta=(t-t[0])-(thetaStraight-thetaStraight[0])

                #the interpolation should be strictly monotonic. Enforcing continuity to the fifth derivative (k=5) is very likely to ensure that.
                tckp=interpolate.splrep(thetaStraight, tDelta, k=5, per=True)
                tDeltaInt = interpolate.splev( (t_-thetaStraight[0])%max(thetaStraight-thetaStraight[0])+thetaStraight[0] ,tckp, ext=2)

                #now t0 represents the real thetas at which I get uniform straightline theta sampling
                #t0 is equal to the uniformly sampled straigthline theta plus the interpolated tDelta angle and some phase constants
                t0= tDeltaInt + t_ + t[0] - thetaStraight[0]

                if t[0]<t[1]:
                    t0=-t0
                    t=-t

                theta.append(t0)

#                if k==self['levels'].size-1:
#                    pyplot.figure()
#                    pyplot.plot(
#                        thetaStraight,tDelta,'o',
#                        (t_-thetaStraight[0])%max(thetaStraight-thetaStraight[0])+thetaStraight[0],tDeltaInt,'.-r',
#                    )
#                    pyplot.figure()
#                    pyplot.plot(
#                        thetaStraight,t,'o',
#                        t_,t0,'.-r',
#                    )

        if self['levels'][0]==0:
            if theta[1][0]<theta[1][-1]:
                theta[0]=np.linspace(min(theta[1]),min(theta[1])+2*np.pi,np_)
            else:
                theta[0]=np.linspace(min(theta[1])+2*np.pi,min(theta[1]),np_)

        return theta

    def surfAvg(self, function=None):
        """
        Flux surface averaged quantity for each flux surface
        :param function: function which returns the value of the quantity to be flux surface averaged at coordinates r,z
        :return: array of the quantity fluxs surface averaged for each flux surface
        :Example:
        >> def test_avg_function(r, z):
        >>     return RectBivariateSplineNaN(Z, R, PSI, k=1).ev(z,r)
        """
        t0 = datetime.datetime.now()
        if not self.calculateAvgGeo:
            return

        self._BrBzAndF()

        #define handy function for flux-surface averaging
        def flxAvg(k,input):
            return np.sum(self.fluxexpansion_dl[k]*input)/self.int_fluxexpansion_dl[k]

        #if user wants flux-surface averaging of a specific function, then calculate and return it
        if function is not None:
            if 'avg' not in self:
                self.surfAvg()
            if not self.quiet: printi('Flux surface averaging of user defined quantity ...')
            avg=np.zeros((self.nc))
            for k in range(self.nc):
                avg[k]= flxAvg(k,function(self['flux'][k]['R'],self['flux'][k]['Z']))
            return avg

        self['avg']=SortedDict()
        self['geo']=SortedDict()
        self['midplane']=SortedDict()
        self['geo']['psi'] = self['levels'] * (self.flx - self.PSIaxis) + self.PSIaxis
        self['geo']['psin'] = self['levels']

        #calculate flux surface average of typical quantities
        if not self.quiet: printi('Flux surface averaging ...')
        for item in ['R','a','R**2','1/R','1/R**2','Bp','Bp**2','Bp*R','Bp**2*R**2','Btot','Btot**2','Bt','Bt**2','ip','vp','q','hf','Jt','Jt/R','fc','grad_term','P','F','PPRIME','FFPRIM']:
            self['avg'][item]=np.zeros((self.nc))
        for k in range(self.nc):
            Bp2=self['flux'][k]['Br']**2+self['flux'][k]['Bz']**2
            signBp = self._cocos['sigma_rhotp']*self._cocos['sigma_RpZ']*np.sign((self['flux'][k]['Z']-self['Z0'])*self['flux'][k]['Br']-(self['flux'][k]['R']-self['R0'])*self['flux'][k]['Bz'])
            Bp=signBp*np.sqrt(Bp2)
            Bt=self['flux'][k]['F']/self['flux'][k]['R']
            B2=Bp2+Bt**2
            B=np.sqrt(B2)
            bratio=B/np.max(B)
            self['flux'][k]['Bmax']=np.max(B)

            #self['avg']['psi'][k]       = flxAvg(k, function(self['flux'][k]['R'],self['flux'][k]['Z']) )
            self['avg']['R'][k]         = flxAvg(k, self['flux'][k]['R'] )
            self['avg']['a'][k]         = flxAvg(k, np.sqrt((self['flux'][k]['R']-self['R0'])**2+(self['flux'][k]['Z']-self['Z0'])**2) )
            self['avg']['R**2'][k]      = flxAvg(k, self['flux'][k]['R']**2 )
            self['avg']['1/R'][k]       = flxAvg(k, 1./self['flux'][k]['R'] )
            self['avg']['1/R**2'][k]    = flxAvg(k, 1./self['flux'][k]['R']**2 )
            self['avg']['Bp'][k]        = flxAvg(k, Bp )
            self['avg']['Bp**2'][k]     = flxAvg(k, Bp2 )
            self['avg']['Bp*R'][k]      = flxAvg(k, Bp*self['flux'][k]['R'] )
            self['avg']['Bp**2*R**2'][k]= flxAvg(k, Bp2*self['flux'][k]['R']**2 )
            self['avg']['Btot'][k]      = flxAvg(k, B )
            self['avg']['Btot**2'][k]   = flxAvg(k, B2 )
            self['avg']['Bt'][k]        = flxAvg(k, Bt )
            self['avg']['Bt**2'][k]     = flxAvg(k, Bt**2 )
            self['avg']['vp'][k]        = self._cocos['sigma_rhotp']*self._cocos['sigma_Bp']*np.sign(self['avg']['Bp'][k])*self.int_fluxexpansion_dl[k]*(2.*np.pi)**(1.-self._cocos['exp_Bp'])
            self['avg']['q'][k]         = self._cocos['sigma_rhotp']*self._cocos['sigma_Bp']*self['avg']['vp'][k]*self['flux'][k]['F']*self['avg']['1/R**2'][k]/((2*np.pi)**(2.-self._cocos['exp_Bp']))
            self['avg']['hf'][k]        = flxAvg(k, ( 1. - np.sqrt(1.-bratio)*(1.+bratio/2.) )/bratio**2 )

            # these quantites are calculated from Bx,By and hence are not that precise
            # if information is available about P, PPRIME, and F, FFPRIM then they will be substittuted
            self['avg']['ip'][k]        = self._cocos['sigma_rhotp']*np.sum(self.dl[k]*Bp)/(4E-7*np.pi)
            self['avg']['Jt'][k]        = flxAvg(k, self['flux'][k]['Jt'] )
            self['avg']['Jt/R'][k]      = flxAvg(k, self['flux'][k]['Jt']/self['flux'][k]['R'] )
            self['avg']['F'][k]=self['flux'][k]['F']
            if hasattr(self,'P'):
                self['avg']['P'][k]=self['flux'][k]['P']
            elif 'P' in self['avg']:
                del self['avg']['P']
            if hasattr(self,'PPRIME'):
                self['avg']['PPRIME'][k]=self['flux'][k]['PPRIME']
            elif 'PPRIME' in self['avg']:
                del self['avg']['PPRIME']
            if hasattr(self,'FFPRIM'):
                self['avg']['FFPRIM'][k]=self['flux'][k]['FFPRIM']
            elif 'FFPRIM' in self['avg']:
                del self['avg']['FFPRIM']

            ## The circulating particle fraction calculation has been converted from IDL to python
            ## following the fraction_circ.pro which is widely used at DIII-D
            ## Formula 4.54 of S.P. Hirshman and D.J. Sigmar 1981 Nucl. Fusion 21 1079
            #x=array([0.0387724175, 0.1160840706, 0.1926975807, 0.268152185, 0.3419940908, 0.4137792043, 0.4830758016, 0.549467125, 0.6125538896, 0.6719566846, 0.7273182551, 0.7783056514, 0.8246122308, 0.8659595032, 0.9020988069, 0.9328128082, 0.9579168192, 0.9772599499, 0.9907262386, 0.9982377097])
            #w=array([0.0775059479, 0.0770398181, 0.0761103619, 0.074723169, 0.0728865823, 0.0706116473, 0.0679120458, 0.0648040134, 0.0613062424, 0.057439769, 0.0532278469, 0.0486958076, 0.0438709081, 0.0387821679, 0.0334601952, 0.0279370069, 0.0222458491, 0.0164210583, 0.0104982845, 0.004521277])
            #lmbd   = 1-x**2
            #weight = 2.*w*np.sqrt(1. - lmbd)
            #denom  = np.zeros((len(lmbd)))
            #for n in range(len(lmbd)):
            #    denom[n] = flxAvg(k, np.sqrt(1.-lmbd[n]*bratio) )
            #integral=np.sum(weight*lmbd/denom)
            #self['avg']['fc'][k]        =0.75*self['avg']['Btot**2'][k]/np.max(B)**2*integral
            #
            #The above calculation is exactly equivalent to the Lin-Lu form of trapped particle fraction
            #article: Y.R. Lin-Liu and R.L. Miller, Phys. of Plamsas 2 (1995) 1666
            h=self['avg']['Btot'][k]/self['flux'][k]['Bmax']
            h2=self['avg']['Btot**2'][k]/self['flux'][k]['Bmax']**2
            # Equation 4
            ftu = 1. - h2/(h**2) * ( 1. - np.sqrt(1. - h)*( 1. + 0.5*h ) )
            # Equation 7
            ftl = 1. - h2*self['avg']['hf'][k]
            # Equation 18,19
            self['avg']['fc'][k] = 1-( 0.75*ftu + 0.25*ftl )

            grad_parallel=np.diff(B)/self.fluxexpansion_dl[k][1:]/B[1:]
            self['avg']['grad_term'][k] =np.sum(self.fluxexpansion_dl[k][1:]*grad_parallel**2)/self.int_fluxexpansion_dl[k]

        if 'P' in self['avg'] and 'PPRIME' not in self['avg']:
            self['avg']['PPRIME']=deriv(self['geo']['psi'],self['avg']['P'])

        if 'F' in self['avg'] and 'FFPRIM' not in self['avg']:
            self['avg']['FFPRIM']=self['avg']['F']*deriv(self['geo']['psi'],self['avg']['F'])

        if 'PPRIME' in self['avg'] and 'FFPRIM' in self['avg']:
            self['avg']['Jt/R']=-self._cocos['sigma_Bp']*(self['avg']['PPRIME']+self['avg']['FFPRIM']*self['avg']['1/R**2']/(4*np.pi*1E-7))*(2.*np.pi)**self._cocos['exp_Bp']

        #calculate currents based on Grad-Shafranov if pressure information is available
        if 'PPRIME' in self['avg'] and 'F' in self['avg'] and 'FFPRIM' in self['avg']:
            fprime=self['avg']['FFPRIM']/self['avg']['F']
            self['avg']['dip/dpsi']=-self._cocos['sigma_Bp']*self['avg']['vp']*(self['avg']['PPRIME'] + self['avg']['FFPRIM']*self['avg']['1/R**2']/(4E-7*np.pi))/((2*np.pi)**(1.-self._cocos['exp_Bp']))
            self['avg']['ip']=integrate.cumtrapz(self['avg']['dip/dpsi'],self['geo']['psi'],initial=0)
        else:
            self['avg']['dip/dpsi']=deriv(self['geo']['psi'],self['avg']['ip'])
        self['avg']['Jeff']=self._cocos['sigma_Bp']*self._cocos['sigma_rhotp']*self['avg']['dip/dpsi']*self['BCENTR']/(self['avg']['q']*(2*np.pi)**(1.-self._cocos['exp_Bp']))
        self['CURRENT']=self['avg']['ip'][-1]

        #q on axis by extrapolation
        if self['levels'][0]==0:
            x = self['levels'][1:]
            y = self['avg']['q'][1:]
            self['avg']['q'][0] = y[1] - ((y[1] - y[0]) / (x[1] - x[0])) * x[1]
        for k in range(self.nc):
            self['flux'][k]['q']=self['avg']['q'][k]

        #calculate geometric quantities
        if not self.quiet: printi('  > Took {:}'.format(datetime.datetime.now() - t0))
        if not self.quiet: printi('Geometric quantities ...')
        t0 = datetime.datetime.now()
        for k in range(self.nc):
            geo = fluxGeo(self['flux'][k]['R'], self['flux'][k]['Z'], lcfs=(k==(self.nc-1)))
            for item in sorted(geo):
                if item not in self['geo']:
                    self['geo'][item] = np.zeros((self.nc))
                self['geo'][item][k] = geo[item]
        self['geo']['vol']=self.volume_integral(1) # abs(scipy.integrate.cumtrapz(self['avg']['vp'],self['geo']['psi'],initial=0))
        self['geo']['cxArea']=self.surface_integral(1) # abs(scipy.integrate.cumtrapz(self['avg']['vp']*self['avg']['1/R'],self['geo']['psi'],initial=0))
        self['geo']['phi'] = self._cocos['sigma_Bp']*self._cocos['sigma_rhotp']*integrate.cumtrapz(self['avg']['q'],self['geo']['psi'],initial=0)*(2.*np.pi)**(1.-self._cocos['exp_Bp'])
        #self['geo']['bunit']=(abs(self['avg']['q'])/self['geo']['a'])*( deriv(self['geo']['a'],self['geo']['psi']) )
        self['geo']['bunit']=deriv(self['geo']['a'],self['geo']['phi'])/(2.*np.pi*self['geo']['a'])

        # fix geometric quantities on axis
        if self['levels'][0] == 0:
            self['geo']['delu'][0] = 0.
            self['geo']['dell'][0] = 0.
            self['geo']['delta'][0] = 0.
            self['geo']['zeta'][0] = 0.
            self['geo']['zetaou'][0] = 0.
            self['geo']['zetaiu'][0] = 0.
            self['geo']['zetail'][0] = 0.
            self['geo']['zetaol'][0] = 0.
            # linear extrapolation
            x = self['levels'][1:]
            for item in ['kapu', 'kapl', 'bunit']:
                y = self['geo'][item][1:]
                self['geo'][item][0] = y[1] - ((y[1] - y[0]) / (x[1] - x[0])) * x[1]
            self['geo']['kap'][0] = 0.5 * self['geo']['kapu'][0] + 0.5 * self['geo']['kapl'][0]
            #  calculate rho only if levels start from 0
            self['geo']['rho'] = np.sqrt(np.abs(self['geo']['phi'] / (np.pi * self['BCENTR'])))
        else:
            # the values of phi, rho have meaning only if I can integrate from the first flux surface on...
            if 'phi' in self['geo']: del self['geo']['phi']
            if 'rho' in self['geo']: del self['geo']['rho']

        #calculate betas
        if 'P' in self['avg']:
            Btvac = self['BCENTR'] * self['RCENTR'] / self['geo']['R'][-1]
            self['avg']['beta_t'] = self.volume_integral(self['avg']['P'] / (Btvac ** 2 / 2.0 / 4.0 / np.pi / 1E-7)) / self['geo']['vol'][-1] * 100
            i = self['CURRENT'] / 1E6
            a = self['geo']['a'][-1]
            self['avg']['beta_n'] = self['avg']['beta_t'] / abs(i / a / Btvac)
            bpave = self['CURRENT'] * (4 * np.pi * 1E-7) / self['geo']['per'][-1]
            self['avg']['beta_p'] = self.volume_integral(self['avg']['P'] / (bpave ** 2 / 2.0 / 4.0 / np.pi / 1E-7)) / self['geo']['vol'][-1]

        #the values of rhon has a meaning only if if I have the value at the lcfs
        if 'rho' in self['geo'] and self['levels'][self.nc-1]==1.0:
            self['geo']['rhon'] = self['geo']['rho']/max(self['geo']['rho'])

            #fcap, f(psilim)/f(psi)
            self['avg']['fcap'] = np.zeros((self.nc))
            for k in range(self.nc):
                self['avg']['fcap'][k] = self['flux'][k]['F']/self['flux'][self.nc-1]['F']

            #hcap, fcap / <R0**2/R**2>
            self['avg']['hcap'] = self['avg']['fcap'] / (self['R0']**2 * self['avg']['1/R**2'])

            #RHORZ (linear extrapolation for rho>1)
            def ext_arr_linear(x, y):
                dydx = (y[-1]-y[-2])/(x[-1]-x[-2])
                extra_x = (x[-1]-x[-2])*np.r_[1:1000]+ x[-1]
                extra_y = (x[-1]-x[-2])*np.r_[1:1000]*dydx + y[-1]
                x = np.hstack((x, extra_x))
                y = np.hstack((y, extra_y))
                return [x,y]
            [new_psi_mesh0, new_PHI]=ext_arr_linear(self['geo']['psi'], self['geo']['phi'])
            PHIRZ=interpolate.interp1d(new_psi_mesh0, new_PHI, kind='linear', bounds_error=False)(self.PSIin)
            RHORZ=np.sqrt(abs(2*np.pi*PHIRZ/np.pi/self['BCENTR']))

            #gcap
            dRHOdZ,dRHOdR=np.gradient(RHORZ, self.Zin[2]-self.Zin[1], self.Rin[2]-self.Rin[1])
            # dRHOdZ=np.diff(RHORZ,axis=0)*(self.Zin[2]-self.Zin[1])
            # dRHOdZ=np.vstack((np.zeros((1,dRHOdZ.shape[1])),dRHOdZ))
            # dRHOdR=np.diff(RHORZ,axis=1)*(self.Rin[2]-self.Rin[1])
            # dRHOdR=np.hstack((np.zeros((dRHOdR.shape[0],1)),dRHOdR))
            dPHI2=dRHOdZ**2+dRHOdR**2
            dp2fun = RectBivariateSplineNaN(self.Zin, self.Rin, dPHI2)
            self['avg']['gcap'] = np.zeros((self.nc))
            for k in range(self.nc):
                self['avg']['gcap'][k] = np.sum(self.fluxexpansion_dl[k]*dp2fun.ev(self['flux'][k]['Z'],self['flux'][k]['R']))/self.int_fluxexpansion_dl[k]
            self['avg']['gcap'] *= self['RCENTR'] ** 2 * self['avg']['1/R**2']

        else:
            if 'rhon' in self['geo']:
                del self['geo']['rhon']

        #midplane quantities
        self['midplane']['R'] = self['geo']['R'] + self['geo']['a']
        self['midplane']['Z'] = self['midplane']['R'] * 0 + self['Z0']

        Br, Bz = self._calcBrBz()
        self['midplane']['Br'] = RectBivariateSplineNaN(self.Zin, self.Rin, Br).ev(self['midplane']['Z'],
                                                                                   self['midplane']['R'])
        self['midplane']['Bz'] = RectBivariateSplineNaN(self.Zin, self.Rin, Bz).ev(self['midplane']['Z'],
                                                                                   self['midplane']['R'])

        signBp = -self._cocos['sigma_rhotp']*self._cocos['sigma_RpZ']*np.sign(self['midplane']['Bz'])
        self['midplane']['Bp'] = signBp*np.sqrt(self['midplane']['Br']**2 + self['midplane']['Bz']**2)

        self['midplane']['Bt'] = []
        for k in range(self.nc):
            self['midplane']['Bt'].append(self['flux'][k]['F'] / self['midplane']['R'][k])
        self['midplane']['Bt'] = np.array(self['midplane']['Bt'])

        #============
        # extra infos
        #============
        self['info'] = SortedDict()

        self['info']['J_efit_norm'] = (self['RCENTR'] * self['avg']['1/R']) * self['avg']['Jt'] / (self['CURRENT'] / self['geo']['cxArea'][-1])

        # open separatrix
        if self.open_sep is not None:
            try:
                self['info']['open_separatrix'] = self.sol(levels=[1], open_flx={1: self.open_sep})[0][0]
            except Exception as _excp:
                printw('Error tracing open field-line separatrix: ' + repr(_excp))
                self['info']['open_separatrix'] = _excp
            else:
                ros = self['info']['open_separatrix']['R']
                istrk = np.array(
                    [0, -1] if ros[-1] > ros[0] else [-1, 0])  # Sort it so it goes inner, then outer strk pt
                self['info']['rvsin'], self['info']['rvsout'] = ros[istrk]
                self['info']['zvsin'], self['info']['zvsout'] = self['info']['open_separatrix']['Z'][istrk]

        # primary xpoint
        i = np.argmin(np.sqrt(self['flux'][self.nc - 1]['Br'] ** 2 + self['flux'][self.nc - 1]['Bz'] ** 2))
        self['info']['xpoint'] = np.array([self['flux'][self.nc - 1]['R'][i], self['flux'][self.nc - 1]['Z'][i]])

        # identify sol regions (works for single x-point >> do not do this for double-X-point or limited cases)
        if ('rsvin' in self['info'] and 'zvsin' in self['info'] and
                np.sign(self.open_sep[0, 1]) == np.sign(self.open_sep[-1, 1]) and
                self.open_sep[0, 1] != self.open_sep[-1, 1] and self.open_sep[0, 0] != self.open_sep[-1, 0]):
            rx, zx = self['info']['xpoint']

            # find minimum distance between legs of open separatrix used to estimate circle radius `a`
            k = int(len(self.open_sep) // 2)
            r0 = self.open_sep[:k, 0]
            z0 = self.open_sep[:k, 1]
            r1 = self.open_sep[k:, 0]
            z1 = self.open_sep[k:, 1]
            d0 = np.sqrt((r0 - rx) ** 2 + (z0 - zx) ** 2)
            i0 = np.argmin(d0)
            d1 = np.sqrt((r1 - rx) ** 2 + (z1 - zx) ** 2)
            i1 = np.argmin(d1) + k
            a = np.sqrt((self.open_sep[i0, 0] - self.open_sep[i1, 0]) ** 2 + (self.open_sep[i0, 1] - self.open_sep[i1, 1]) ** 2)
            a *= 3

            # circle
            t = np.linspace(0, 2 * np.pi, 101)[:-1]
            r = a * np.cos(t) + rx
            z = a * np.sin(t) + zx

            # intersect open separatrix with small circle around xpoint
            circle = line_intersect(
                np.array([self.open_sep[:,0], self.open_sep[:,1]]).T,
                np.array([r, z]).T)

            if len(circle)==4:

                # always sort points so that they are in [inner_strike, outer_strike, outer_midplane, inner_midplane] order
                circle0 = circle - np.array([rx, zx])[np.newaxis, :]
                # clockwise for upper Xpoint
                if zx > 0 and np.sign(circle0[0, 0] * circle0[1, 1] - circle0[1, 0] * circle0[0, 1]) > 0:
                    circle = circle[::-1]
                # counter clockwise for lower Xpoint
                elif zx < 0 and np.sign(circle0[0, 0] * circle0[1, 1] - circle0[1, 0] * circle0[0, 1]) < 0:
                    circle = circle[::-1]
                # start numbering from inner strike wall
                index = np.argmin(np.sqrt((circle[:, 0] - self['info']['rvsin']) ** 2 + (circle[:, 1] - self['info']['zvsin']) ** 2))
                circle = np.vstack((circle, circle))[index:index + 4, :]
                for k, item in enumerate(['xpoint_inner_strike', 'xpoint_outer_strike', 'xpoint_outer_midplane', 'xpoint_inner_midplane']):
                    try:
                        self['info'][item] = circle[k]
                    except IndexError:
                        printe('Error parsing %s' % item)

                # regions are defined at midway points between the open separatrix points
                regions = circle + np.diff(np.vstack((circle, circle[0])), axis=0) / 2.0
                for k, item in enumerate(['xpoint_private_region', 'xpoint_outer_region', 'xpoint_core_region', 'xpoint_inner_region']):
                    try:
                        self['info'][item] = regions[k]
                    except IndexError:
                        printe('Error parsing %s' % item)

                # secondary xpoint
                if True:

                    # find where Bz=0 on the opposite side of the primary X-point: this is xpoint2_start
                    Bz_sep = self['flux'][self.nc - 1]['Bz'].copy()
                    mask = self['flux'][self.nc - 1]['Z'] * np.sign(self['info']['xpoint'][1]) > 0
                    Bz_sep[mask] = np.nan
                    index = np.nanargmin(abs(Bz_sep))
                    xpoint2_start = [self['flux'][self.nc - 1]['R'][index], self['flux'][self.nc - 1]['Z'][index]]

                    # trace Bz=0 contour and find the contour line that passes closest to xpoint2_start: this is the rz_divider line
                    Bz0 = contourPaths(self.Rin, self.Zin, Bz, [0], remove_boundary_points=True, smooth_factor=1)[0]
                    d = []
                    for item in Bz0:
                        d.append(np.min(np.sqrt(
                            (item.vertices[:, 0] - xpoint2_start[0]) ** 2 + (item.vertices[:, 1] - xpoint2_start[1]) ** 2)))
                    rz_divider = Bz0[np.argmin(d)].vertices

                    # evaluate Br along rz_divider line and consider only side opposite side of the primary X-point
                    Br_divider = RectBivariateSplineNaN(self.Zin, self.Rin, Br).ev(rz_divider[:, 1],rz_divider[:, 0])
                    mask = (rz_divider[:, 1] * np.sign(self['info']['xpoint'][1])) < -abs(self['info']['xpoint'][1]) / 10.
                    Br_divider = Br_divider[mask]
                    rz_divider = rz_divider[mask, :]
                    if abs(rz_divider[0, 1]) > abs(rz_divider[-1, 1]):
                        rz_divider = rz_divider[::-1, :]
                        Br_divider = Br_divider[::-1]

                    # secondary xpoint where Br flips sign
                    try:
                        ix = np.where(np.sign(Br_divider) != np.sign(Br_divider)[0])[0][0]
                        self['info']['xpoint2'] = (rz_divider[ix - 1, :] + rz_divider[ix, :]) * 0.5
                    except IndexError:
                        pass

        # limiter
        if hasattr(self, 'rlim') and self.rlim is not None and len(self.rlim) and hasattr(self,'zlim') and self.zlim is not None and len(self.zlim):
            self['info']['rlim'] = self.rlim
            self['info']['zlim'] = self.zlim

        if not self.quiet:
            printi('  > Took {:}'.format(datetime.datetime.now() - t0))

    def surface_integral(self, what):
        """
        Cross section integral of a quantity
        :param what: quantity to be integrated specified as array at flux surface
        :return: array of the integration from core to edge
        """
        return abs(integrate.cumtrapz(self['avg']['vp']*self['avg']['1/R']*what,self['geo']['psi'],initial=0))/(2.*np.pi)

    def volume_integral(self, what):
        """
        Volume integral of a quantity
        :param what: quantity to be integrated specified as array at flux surface
        :return: array of the integration from core to edge
        """
        return abs(integrate.cumtrapz(self['avg']['vp']*what,self['geo']['psi'],initial=0))

    def _surfMean(self, what):
        tmp=np.zeros((self.nc))
        whatfun = RectBivariateSplineNaN(self.Zin, self.Rin, what)
        for k in range(self.nc):
            pt=int(np.ceil(self['flux'][k]['R'].size/8.0))
            whatSamples=whatfun.ev(self['flux'][k]['Z'][::pt],self['flux'][k]['R'][::pt])
            tmp[k]=np.mean(whatSamples)
        return tmp


    def rz_miller_geometry(self, poloidal_resolution=101):
        '''
        return R,Z coordinates for all flux surfaces from miller geometry coefficients in geo
        # based on gacode/gapy/src/gapy_geo.f90
        :param poloidal_resolution: integer with number of equispaced points in toroidal angle, or array of toroidal angles
        :return: 2D arrays with (R, Z) flux surface coordinates
        '''
        if isinstance(poloidal_resolution, int):
            t0 = np.linspace(0, 2 * np.pi, poloidal_resolution)
        else:
            t0 = poloidal_resolution

        x = np.arcsin(self['geo']['delta'])

        # R
        a = t0[:, newaxis] + x[newaxis, :] * np.sin(t0[:, newaxis])
        r0 = self['geo']['R'][newaxis, :] + self['geo']['a'][newaxis, :] * np.cos(a)

        # Z
        a = t0[:, newaxis] + self['geo']['zeta'][newaxis, :] * np.sin(2 * t0[:, newaxis])
        z0 = self['geo']['Z'][newaxis, :] + self['geo']['kap'][newaxis, :] * self['geo']['a'][newaxis, :] * np.sin(a)

        return r0, z0

    def sol(self, levels=31, packing=3, resolution=0.01, rlim=None, zlim=None, open_flx=None):
        '''
        Trace open field lines flux surfaces in the SOL
        :param levels: where flux surfaces should be traced
           * integer number of flux surface
           * list of levels
        :param packing: if `levels` is integer, packing of flux surfaces close to the separatrix
        :param resolution: accuracy of the flux surface tracing
        :param rlim: list of R coordinates points where flux surfaces intersect limiter
        :param zlim: list of Z coordinates points where flux surfaces intersect limiter
        :param open_flx: dictionary with flux surface rhon value as keys of where to calculate SOL (passing this will not set the `sol` entry in the flux-surfaces class)
        :return: dictionary with SOL flux surface information
        '''

        #pack more surfaces near the separatrix
        if isinstance(levels,int):
            R=np.array([self['R0'],max(self.Rin)])
            tmp=RectBivariateSplineNaN(self.Zin, self.Rin, self.PSIin).ev(R*0+self['Z0'],R)
            tmp=max((tmp-self.PSIaxis)/((self.flx - self.PSIaxis)*self.maxPSI))
            levels=pack_points(levels+2,-1,packing)
            levels=(levels-min(levels))/(max(levels)-min(levels))*(tmp-1)+1
            levels=levels[1:-1]

        if rlim is None:
            rlim = self.rlim
        if zlim is None:
            zlim = self.zlim
        if rlim is None or zlim is None:
            dd = 0.01
            rlim = [min(self.Rin) + dd, max(self.Rin) - dd, max(self.Rin) - dd, min(self.Rin) + dd, min(self.Rin) + dd]
            zlim = [min(self.Zin) + dd, min(self.Zin) + dd, max(self.Zin) - dd, max(self.Zin) - dd, min(self.Zin) + dd]

        rlim=copy.deepcopy(rlim)
        zlim=copy.deepcopy(zlim)

        store_SOL=False
        if open_flx is None:
            store_SOL=True

            # SOL requires higher resolution
            self.changeResolution(resolution)

            # find SOL fied lines
            open_flx=self._findSurfaces(levels=levels)

        # midplane
        Rm=np.array([self['R0'],max(self.Rin)])
        Zm=Rm*0+self['Z0']

        SOL=SortedDict()
        for k,level in enumerate(open_flx.keys()):
            SOL[k]=SortedDict()
            SOL[k]['psi']=level*(self.flx - self.PSIaxis)*self.maxPSI+self.PSIaxis
            SOL[k]['rhon']=level
            SOL[k]['R']=open_flx[level][:,0]
            SOL[k]['Z']=open_flx[level][:,1]

        max_mid=line_intersect(np.array([Rm,Zm]).T,np.array([rlim,zlim]).T)
        if len(max_mid):
            max_mid=max_mid[0]
        else:
            printw('fluxsurfaces: there is no intersection between the horizontal line at the magnetic axis Z and the limiter')
            max_mid=[max(Rm),np.argmax(Rm)]
        def line_split(x1,x2):
            inter_midp,index_midp=line_intersect(x1,x2,True)
            index_midp=index_midp[0][0]
            inter_midp=inter_midp[0]
            if inter_midp[0]>max_mid[0]:
                return None
            inter_wall,index_wall=line_intersect(x1,np.array([rlim,zlim]).T,True)

            i=np.array([k[0] for k in index_wall]).astype(int)
            i1=int(np.where(i==i[np.where(i<index_midp)[0]][-1])[0][0])
            i2=int(np.where(i==i[np.where(i>=index_midp)[0]][0])[0][0])

            legs= np.vstack((x1[:index_wall[i1][0],:],inter_wall[i1])), \
                  np.vstack(([inter_wall[i1]],x1[index_wall[i1][0]+1:index_midp,:],[inter_midp])), \
                  np.vstack(([inter_midp],x1[index_midp+1:index_wall[i2][0],:],[inter_wall[i2]])), \
                  np.vstack(([inter_wall[i2]],x1[index_wall[i2][0]+1:,:])),

            if legs[1][-2][1]<legs[2][1][1]:
                legs=[np.flipud(legs[3]),np.flipud(legs[2]),np.flipud(legs[1]),np.flipud(legs[0])]

            #plot(legs[0][:,0],legs[0][:,1],'b.')
            #plot(legs[1][:,0],legs[1][:,1],'rx')
            #plot(legs[2][:,0],legs[2][:,1],'b.')
            #plot(legs[3][:,0],legs[3][:,1],'rx')
            #print(map(len,legs))

            return legs

        Br,Bz = self._calcBrBz()

        Brfun = RectBivariateSplineNaN(self.Zin, self.Rin, Br)
        Bzfun = RectBivariateSplineNaN(self.Zin, self.Rin, Bz)

        sol_levels=[]
        for k in range(len(SOL)):
            try:
                legs=line_split(np.array([SOL[k]['R'],SOL[k]['Z']]).T,np.array([Rm,Zm]).T)
            except IndexError:
                for k1 in range(k,len(SOL)):
                    del SOL[k1]
                break
            if legs is not None:
                r  = SOL[k]['R'] = np.hstack((legs[0][:-1,0],legs[1][:-1,0],legs[2][:-1,0],legs[3][:,0]))
                z  = SOL[k]['Z'] = np.hstack((legs[0][:-1,1],legs[1][:-1,1],legs[2][:-1,1],legs[3][:,1]))
                w1 = len(legs[0][:-1,0])
                ii = len(legs[0][:-1,0])+len(legs[1][:-1,0])
                w2 = len(legs[0][:-1,0])+len(legs[1][:-1,0])+len(legs[2][:-1,0])
                sol_levels.append(SOL[k]['rhon'])
            else:
                del SOL[k]
                continue

            SOL[k]['Br'] = Brfun.ev(z, r)
            SOL[k]['Bz'] = Bzfun.ev(z, r)

            Bt=abs(self['BCENTR']*self['RCENTR']/r)
            Bp=np.sqrt(SOL[k]['Br']**2+SOL[k]['Bz']**2)

            dp=np.sqrt(np.gradient(r)**2+np.gradient(z)**2)
            pitch=np.sqrt(1+(Bt/Bp)**2)
            s=np.cumsum(pitch*dp)
            s=np.abs(s-s[ii])
            SOL[k]['s']=s

            for item in SOL[k]:
                if isinstance(SOL[k][item],np.ndarray):
                    SOL[k][item]=SOL[k][item][w1:w2+1]
            SOL[k]['mid_index']=ii-w1

            SOL[k]['rho']=SOL[k]['rhon']*self['geo']['rho'][-1]

        if store_SOL:
            self['sol']=SOL
            self['sol_levels']=np.array(sol_levels)
        return SOL,sol_levels

    